18. 4Sum
Medium

Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:

Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

1st answer, accepted. Basically, the answer is the same as 3Sum, using left-right-pointers to solve the problem. Time complexity is cube(n). 
```python
def forSum(nums, target):
    if not nums or len(nums)<4: return []
    nums,li,ans=sorted(nums),[],set()
    for i in range(len(nums)-3):
        if li and nums[i]==li[0]: continue
        if not li: li.append(nums[i])
        else: li[0]=nums[i]
        lj=[]
        for j in range(i+1,len(nums)-2):
            if lj and nums[j]==lj[0]: continue
            if not lj: lj.append(nums[j])
            else: lj[0]=nums[j]
            l,r,t=j+1,len(nums)-1,target-nums[i]-nums[j]
            while l<r:
                if nums[l]+nums[r]<t:
                    l=l+1
                elif nums[l]+nums[r]>t:
                    r=r-1
                else:
                    quad=(nums[i],nums[j],nums[l],nums[r])
                    if quad not in ans:
                        ans.add(quad)
                    l,r=l+1,r-1
    return list(ans)
```

Since I have done three similar problems(3sum, 3sum-closest, 4sum), I believe it's time to write a funcation to solve such k-sum problem.
```python
### assume the array(nums) is sorted.
def KSum(nums, k, target):
    if len(nums)<k: return []
    def func(nums, k, target, res, ans):
        if k==2:
            l,r=0,len(nums)-1
            while l<r:
                if nums[l]+nums[r]<target:
                    l+=1
                elif nums[l]+nums[r]>target:
                    r-=1
                else:
                    ans.append(res+[nums[l],nums[r]])
                    while l+1<len(nums) and l<r and nums[l]==nums[l+1]:
                        l+=1
                    while r-1>-1 and l<r and nums[r]==nums[r-1]:
                        r-=1
        else:
            for i in range(len(nums)-k+1):
                if target<nums[i]*k or target>nums[-1]*k:
                    break
                if i==0 or i>0 and nums[i]!=nums[i-1]:
                    func(nums[1:],k-1,target-nums[i],res+[nums[i]],ans)
    ans=[]
    func(sorted(nums), k, target, [], ans)
    return ans
```